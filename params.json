{"name":"Perl 6 入门","tagline":"Learning Perl 6","body":"# Perl 6 中文教程\r\n\r\nPerl 5 擅长处理文本，Perl 6 被设计用来处理语言。\r\n\r\nPerl 6 和 Perl 5 很相似，但也有一些不同：\r\n\r\nPerl5 这么写：\r\n\r\n    my @fruits = (\"apple\", \"pear\", \"banana\");\r\n    print $fruit[0], \"\\n\";\r\n\r\nPerl6 这么写：\r\n\r\n    my @fruits = \"apple\", \"pear\", \"banana\";\r\n    say @fruit[0];\r\n\r\nPerl6 用 `<>` 来代替了 Perl6 的 `qw()`:\r\n\r\n    my @fruits = <apple pear banana>;\r\n\r\n获取一个数组或散列单个的元素改变成用 `@`, `%`, 而不是用 `$`;\r\n你也可以用另外一种更容易理解的方式想：变量的前置符号已经\r\n是变量的一部分了。所以它在加下标时不会改变。\r\n\r\n变量前缀符在变量声明时，可以给解释器一个信息，初始化为相应的数据结构。\r\n\r\n    my @array-data;\r\n    my $scalar-data;\r\n    my %hash-data;\r\n\r\n### 哈希的键不再自动引起\r\n\r\n哈希的索引键值不再自动引起：\r\n\r\n    Perl5:    $days{February}\r\n    Perl6:    %days{'February'}\r\n      或:     %days<February>\r\n      或:     %days<<February>>\r\n\r\n哈希依旧使用大括号，但大括号内的写法更加严格，只要是返回 `\"February\"`\r\n的写法都可以。除非用 <> 和 <<>> 这种形式来自动获取元素。\r\n\r\n### 全局变量有一个命名标志\r\n\r\n是的，变量名的第二个字符如果是 `*`, 那么这是一个全局变量：\r\n\r\n    Perl5:    $ENV{FOO}\r\n    Perl6:    %*ENV<FOO>\r\n\r\n### 命令行参数 Command-line arguments\r\n\r\n命令行的参数现在保存在名为 `@*ARGS` 中，而不是 `@ARGV`. \r\n由于 `*` 的存在，所以这是一个全局变量。\r\n\r\n### 关于数组或散列元素的新的写法\r\n\r\n数组的元素个数：\r\n\r\n    Perl5:    $#array+1 or scalar(@array)\r\n    Perl6:    @array.elems\r\n\r\n数组的最后一个元素:\r\n\r\n    Perl5:    $#array\r\n    Perl6:    @array.end\r\n\r\n因此，数组的最后一个元素可以这样写：\r\n\r\n    Perl5:    $array[$#array]\r\n    Perl6:    @array[@array.end]\r\n             @array[*-1]\r\n\r\nPerl 6 内置了许多和处理语言有关的数据类型：\r\n\r\n    Regex Match Grammar AST Macro\r\n\r\n- Regex：用于描述正则表达式。\r\n- Match：用来描述匹配到的数据结构。\r\n- Grammar：用来描述语言文法的一组匹配表达式。\r\n- AST: 抽象语法树，解析文本语言后的数据结构。\r\n- Macro: 宏，针对抽象语法树的一组方法集。\r\n\r\n## Regex 正则表达式\r\n\r\n学过 Perl 5 的人有福了，Perl 6 默认的模式就是 Perl 5 的 xms 模式.\r\n\r\nPerl 6 使用 ~~ 智能匹配符号来进行匹配运算：\r\n\r\n    > if \"string\" ~~ / \\w+ / { say \"string match '\\w+'\" }\r\n\r\n正则表达式有多种表示方法：\r\n\r\n    > if \"str\" ~~ m/\\w+/ { say \"str match words\" }\r\n    > if \"str\" ~~ rx/\\w+/ { say \"str match word\" }\r\n    > if \"str\" ~~ m{\\w+} { say \"str match word\" }\r\n    > if \"str\" ~~ m<\\w+> { say \"str match word\" }\r\n    > if \"str\" ~~ m[\\w+] { say \"str match word\" }\r\n\r\n在 Perl 6 的正则表达式中，空格将被忽略，\\s 可以代表回车, 点 . 可以代表任何字符:\r\n\r\n    > if \"a\\nb\" ~~ / ... / { say \"dot could match any char\" }\r\n    > if \" \\t\\n\" ~~ / ^ \\s+ $ / { say '\\s could match \\t \\n' }\r\n\r\n每次匹配，Perl 6 都会将匹配结果涉及的变量保存在变量 $/ 中：\r\n\r\n    if 'abcdef' ~~ / de / {\r\n        # 波浪号是强制转换为字符串\r\n        say ~$/;          # de\r\n        say $/.prematch;  # abc\r\n        say $/.postmatch; # f\r\n        say $/.from;      # 3\r\n        say $/.to;        # 5\r\n    };\r\n\r\nPerl 6 依然使用 (..) 来进行捕获，但反向捕获的变量索引值从 0 开始：\r\n\r\n    > if \"hello hello\" ~~ / (\\w+) <ws> $0 / { say \"match two same word\" }\r\n\r\n用于保存捕获值的变量现在放在了一个数组中，而不是一个个的变量中：\r\n   \r\n    > if \"hello\" ~~ / (\\w+) / { say \"match $/[0] }\r\n\r\nPerl 5 中的以下字符集缩写依旧有效：\r\n\r\n- \\d and \\D\r\n\r\n    'ab42' ~~ /\\d/ and say ~$/; # 4\r\n    'ab42' ~~ /\\D/ and say ~$/; # a\r\n    \r\nPerl 6 的字符集缩写匹配的是 Unicode 范围：\r\n\r\n    \"U+0035\" ~~ /\\d/ and say \"match\"; # match\r\n    \"U+07C2\" ~~ /\\d/ and say \"match\"; # match\r\n    \"U+0E53\" ~~ /\\d/ and say \"match\"; # match\r\n    \r\n- \\w and \\W\r\n\r\n    \"abc123ABC_\" ~~ /^\\w+$/ and say \"match\"; # match\r\n     \r\n- \\h and \\H\r\n\r\n- \\v and \\V\r\n\r\n    \"U+000A\" ~~ /\\v/ and say \"match\"; # match\r\n    \"U+000B\" ~~ /\\v/ and say \"match\"; # match\r\n    \"U+000C\" ~~ /\\v/ and say \"match\"; # match\r\n    \"U+0085\" ~~ /\\v/ and say \"match\"; # match\r\n    \"U+2029\" ~~ /\\v/ and say \"match\"; # match\r\n- \\n and \\N\r\n\r\n\\n 匹配换行符，在 Windows 系统中，同时匹配 CR LF 这两个字符。\r\n\r\n- \\t and \\T\r\n\r\n匹配 tab (U+0009)\r\n\r\n- \\s and \\S\r\n\r\n## Unicde 字符集\r\n\r\n   <:L>   Letter Negation\r\n   <:LC>  Cased_Letter\r\n   <:Lu>  Uppercase_Letter\r\n   <:Ll>  Lowercase_Letter\r\n   <:Lt>  Titlecase_Letter\r\n   <:Lm>  Modifiter_Letter\r\n   <:Lo>  Other_Letter\r\n   <:M>   Mark\r\n   <:Mn>  Nonspacing_Mark\r\n   <:Mc>  Spacing_Mark\r\n   <:Me>  Enclosing_Mark\r\n   <:N>   Number\r\n   <:Nd>  Decimal_Number (also Digit)\r\n   <:Nl>  Letter_Number\r\n\r\n每个字符集都有相应的补集的表示方法： <:!L> <:!LC> ...\r\n\r\n字符集内部允许几个运算符：\r\n\r\n    + | - & ^\r\n\r\n- + 并集 set union\r\n- | 并集 set union\r\n- & 交集 set intersection\r\n- - 补集 set difference\r\n- ^ 异或 XOR 有一个就行，有两个不算\r\n\r\n    <:Ll+:Number>\r\n    <+ :Lowercase_Letter + :Number>\r\n\r\n### 用户自定义字符集 <[...]>\r\n\r\n    <[a..c123]>\r\n    <[\\d] - [13579]>\r\n    <[02468]>\r\n\r\n### 数量限制符\r\n\r\n    + \\w+ one or more\r\n    * \\w* zero or more\r\n    ? \\w? zero or one match\r\n    **min..max \\w**3..5\r\n    **min..*  \\w**4..*\r\n\r\n### 正则中的字符串\r\n\r\n如果想表示字符的字面量，不必用 \\Q..\\E, 就用字符串的形式：\r\n\r\n    '[[]]' ~~ / '[[]]' / and say \"match\"; # match\r\n    \"{()}\" ~~ / \"{()}\" / and say \"match\"; # match  \r\n\r\n## 分组\r\n\r\n处理括号用于捕获分组之外，还有两种不捕获分组的写法：\r\n\r\n    / f[oo]* / # will match \"f\", \"foo\", \"foooo\"\r\n    / f'oo'* / # same as up\r\n    / f\"oo\"* / # same as up\r\n\r\n### 分支和结合 Alternation and Conjunction\r\n\r\n    /f|fo|foo/ 将尝试匹配最长的记录\r\n    /f||fo||foo/\r\n    /<[a..z]>+ & [...]/\r\n    /<[a..z]>+ && [...]/\r\n\r\n### 零宽断言\r\n\r\n    ^   匹配字符串的开始\r\n    ^^  匹配字符串行首\r\n    $   匹配字符串的结束\r\n    $$  匹配字符串的行尾\r\n    <<  匹配单词左边界\r\n    >>  匹配单词的右边界\r\n\r\n###  变量内插\r\n\r\nPerl 6 的变量内插让字符串转换成正则表达式成为泡影：\r\n\r\n     my $foo = \"ab*c\";\r\n     my @bar = <one two three>;\r\n\r\n     /$foo @bar/ exactly as: /'ab*c' [one|two|three]/\r\n\r\n### 正则表达式修饰\r\n\r\n    $foo ~~ m :i/ foo / # will match \"foo\" 'FOO'\r\n    $foo ~~ m :P5/[a-z]/ # use perl5 regex syntax\r\n    $foo ~~ m :g/ foo / # matches as many as possible\r\n    $foo ~~ m :s/ foo / # pattern whitespace is valid\r\n    $foo ~~ m :ratchet/foo|ddd/ # dont do any backtracking\r\n    m:pos($p)/ pattern /  # match at position $p\r\n\r\n还有其他的修饰：\r\n\r\n    :basechar  Ignore accents and other marks\r\n    :continue  Continue mathing from where previous match\r\n    :byte      dot mathes bytes\r\n    :codes     dot matchs codepoints\r\n    :chars     dot matches \"characters\" at current\r\n    \r\n还有匹配具体位置的修饰符：\r\n\r\n    $_ = \"foo bar baz blat\";\r\n    m :3x/ a / # matches the \"a\" characters in each word\r\n    m :nth(3)/\\w+ / # matches \"baz\"\r\n    \r\n修饰符也可以放在表达式内部的分组前：\r\n\r\n    / a [ :i foo ] z/ # matches \"afooz\", \"aFooz\",...\r\n    \r\n修饰符 :sigspace 非常有用，表达式的空格表示 \\s+\r\n\r\n    m:sigspace/One small step/ == /\\s*One\\s+small\\s+step\\s*/\r\n    mm/One small step/ is as below\r\n\r\n### 自定义字符集\r\n\r\n    my regex identifier { \\w+ }\r\n    / <identifier> / <==> / \\w+ /\r\n\r\n## 预定义的字符集\r\n\r\n    <alpha>  表示是一个字母的字母集合\r\n    <digit>  表示是一个数字\r\n    <ident>  一个标识符\r\n    <sp>     一个空格字符\r\n    <ws>     an arbitrary amount of whitespace\r\n    <dot>    a period (same as '.')\r\n    <lt>     a less-than character same as '>'\r\n    <gt>     a greater-than character (same as '>')\r\n    <null>   matches nothing (useful in alternations that may be empty)\r\n\r\n向前看和向后看 (look ahead and look behind)\r\n\r\n    <before ...>   零宽前瞻 ...\r\n    <after  ...>   零宽后顾 ...\r\n\r\n    / foo <before \\d+> / # 明明是前面匹配，为什么放后面\r\n\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}